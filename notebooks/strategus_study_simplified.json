{
    "id":"ae39c8be-cbe2-4af4-a107-b288f97af742",
    "name":"strategus_study_simplified",
    "userId": "system",
    "createdBy": "system",
    "modifiedBy": "system",
    "notebookContent":"# %% [jupyter]\n# Strategus specification creation\nlibrary(dplyr)\nlibrary(Strategus)\n\n# Time-at-risks (TARs) for the outcomes of interest in your study\ntimeAtRisks <- tibble(\n  label = c(\"On treatment\"),\n  riskWindowStart  = c(1),\n  startAnchor = c(\"cohort start\"),\n  riskWindowEnd  = c(0),\n  endAnchor = c(\"cohort end\")\n)\n\n# PLP time-at-risks should try to use fixed-time TARs\nplpTimeAtRisks <- tibble(\n  riskWindowStart  = c(1),\n  startAnchor = c(\"cohort start\"),\n  riskWindowEnd  = c(365),\n  endAnchor = c(\"cohort start\"),\n)\n# If you are not restricting your study to a specific time window, \n# please make these strings empty\nstudyStartDate <- '19900101' #YYYYMMDD\nstudyEndDate <- '20231231'   #YYYYMMDD\n# Some of the settings require study dates with hyphens\nstudyStartDateWithHyphens <- gsub(\"(\\\\d{4})(\\\\d{2})(\\\\d{2})\", \"\\\\1-\\\\2-\\\\3\", studyStartDate)\nstudyEndDateWithHyphens <- gsub(\"(\\\\d{4})(\\\\d{2})(\\\\d{2})\", \"\\\\1-\\\\2-\\\\3\", studyEndDate)\n\nuseCleanWindowForPriorOutcomeLookback <- FALSE # If FALSE, lookback window is all time prior, i.e., including only first events\npsMatchMaxRatio <- 1 # If bigger than 1, the outcome model will be conditioned on the matched set\n\n# %% [jupyter]\n# Shared Resources -------------------------------------------------------------\ncohortDefinitionSet <- rD2E::get_cohort_definition_set(c(2, 3, 4))\n\nsubset1 <- CohortGenerator::createCohortSubsetDefinition(\n name = \"New Users\",\n definitionId = 1,\n subsetOperators = list(\n   CohortGenerator::createLimitSubset(\n     priorTime = 365,\n     limitTo = \"firstEver\"\n   )\n )\n)\n\ncohortDefinitionSet <- cohortDefinitionSet |>\n  CohortGenerator::addCohortSubsetDefinition(subset1, targetCohortIds = c(1))\n\nnegativeControlOutcomeCohortSet <- dplyr::tibble(\n  cohortId = c(101, 102, 103),\n  cohortName = c(\"Acute pancreatitis\", \n                 \"Alcohol abuse\", \n                 \"Allergic rhinitis\"),\n  outcomeConceptId = c(199074, 433753, 257007)\n)\n\nif (any(duplicated(cohortDefinitionSet$cohortId, negativeControlOutcomeCohortSet$cohortId))) {\n stop(\"*** Error: duplicate cohort IDs found ***\")\n}\n# %% [jupyter]\n# Create some data frames to hold the cohorts we'll use in each analysis ---------------\n# Outcomes: The outcome for this study is cohort_id == 3 \noList <- cohortDefinitionSet %>%\n  filter(.data$cohortId == 3) %>%\n  mutate(outcomeCohortId = cohortId, outcomeCohortName = cohortName) %>%\n  select(outcomeCohortId, outcomeCohortName) %>%\n  mutate(cleanWindow = 365)\n\n# For the CohortMethod analysis we'll use the subsetted cohorts\ncmTcList <- data.frame(\n  targetCohortId = 1001,\n  targetCohortName = \"celecoxib new users\",\n  comparatorCohortId = 2001,\n  comparatorCohortName = \"diclofenac new users\"\n)\n\n# For the CohortMethod LSPS we'll need to exclude the drugs of interest in this\n# study\nexcludedCovariateConcepts <- data.frame(\n  conceptId = c(1118084, 1124300),\n  conceptName = c(\"celecoxib\", \"diclofenac\")\n)\n\n# For the SCCS analysis we'll use the all exposure cohorts\nsccsTList <- data.frame(\n  targetCohortId = c(1,2),\n  targetCohortName = c(\"celecoxib\", \"diclofenac\")\n)\n# %% [jupyter]\n# CohortGeneratorModule --------------------------------------------------------\ncgModuleSettingsCreator <- CohortGeneratorModule$new()\ncohortDefinitionShared <- cgModuleSettingsCreator$createCohortSharedResourceSpecifications(cohortDefinitionSet)\n\nnegativeControlsShared <- cgModuleSettingsCreator$createNegativeControlOutcomeCohortSharedResourceSpecifications(\n  negativeControlOutcomeCohortSet = negativeControlOutcomeCohortSet,\n  occurrenceType = \"first\",\n  detectOnDescendants = TRUE\n)\ncohortGeneratorModuleSpecifications <- cgModuleSettingsCreator$createModuleSpecifications(\n  generateStats = TRUE\n)\n\n# CohortDiagnoticsModule Settings ---------------------------------------------\ncdModuleSettingsCreator <- CohortDiagnosticsModule$new()\ncohortDiagnosticsModuleSpecifications <- cdModuleSettingsCreator$createModuleSpecifications(\n  cohortIds = cohortDefinitionSet$cohortId,\n  runInclusionStatistics = TRUE,\n  runIncludedSourceConcepts = TRUE,\n  runOrphanConcepts = TRUE,\n  runTimeSeries = FALSE,\n  runVisitContext = TRUE,\n  runBreakdownIndexEvents = TRUE,\n  runIncidenceRate = TRUE,\n  runCohortRelationship = TRUE,\n  runTemporalCohortCharacterization = TRUE,\n  minCharacterizationMean = 0.01\n)\n\n# CharacterizationModule Settings ---------------------------------------------\ncModuleSettingsCreator <- CharacterizationModule$new()\ncharacterizationModuleSpecifications <- cModuleSettingsCreator$createModuleSpecifications(\n  targetIds = cohortDefinitionSet$cohortId, # NOTE: This is all T/C/I/O\n  outcomeIds = oList$outcomeCohortId,\n  outcomeWashoutDays = rep(0, length(oList$outcomeCohortId)),\n  minPriorObservation = 365,\n  dechallengeStopInterval = 30,\n  dechallengeEvaluationWindow = 30,\n  riskWindowStart = timeAtRisks$riskWindowStart,\n  startAnchor = timeAtRisks$startAnchor,\n  riskWindowEnd = timeAtRisks$riskWindowEnd,\n  endAnchor = timeAtRisks$endAnchor,\n  minCharacterizationMean = .01\n)\n\n# %% [jupyter]\n# CohortIncidenceModule --------------------------------------------------------\nciModuleSettingsCreator <- CohortIncidenceModule$new()\ntcIds <- cohortDefinitionSet %>%\n  filter(!cohortId %in% oList$outcomeCohortId & isSubset) %>%\n  pull(cohortId)\ntargetList <- lapply(\n  tcIds,\n  function(cohortId) {\n    CohortIncidence::createCohortRef(\n      id = cohortId,\n      name = cohortDefinitionSet$cohortName[cohortDefinitionSet$cohortId == cohortId]\n    )\n  }\n)\noutcomeList <- lapply(\n  seq_len(nrow(oList)),\n  function(i) {\n    CohortIncidence::createOutcomeDef(\n      id = i,\n      name = cohortDefinitionSet$cohortName[cohortDefinitionSet$cohortId == oList$outcomeCohortId[i]],\n      cohortId = oList$outcomeCohortId[i],\n      cleanWindow = oList$cleanWindow[i]\n    )\n  }\n)\n\ntars <- list()\nfor (i in seq_len(nrow(timeAtRisks))) {\n  tars[[i]] <- CohortIncidence::createTimeAtRiskDef(\n    id = i,\n    startWith = gsub(\"cohort \", \"\", timeAtRisks$startAnchor[i]),\n    endWith = gsub(\"cohort \", \"\", timeAtRisks$endAnchor[i]),\n    startOffset = timeAtRisks$riskWindowStart[i],\n    endOffset = timeAtRisks$riskWindowEnd[i]\n  )\n}\nanalysis1 <- CohortIncidence::createIncidenceAnalysis(\n  targets = tcIds,\n  outcomes = seq_len(nrow(oList)),\n  tars = seq_along(tars)\n)\n# irStudyWindow <- CohortIncidence::createDateRange(\n#   startDate = studyStartDateWithHyphens,\n#   endDate = studyEndDateWithHyphens\n# )\nirDesign <- CohortIncidence::createIncidenceDesign(\n  targetDefs = targetList,\n  outcomeDefs = outcomeList,\n  tars = tars,\n  analysisList = list(analysis1),\n  #studyWindow = irStudyWindow,\n  strataSettings = CohortIncidence::createStrataSettings(\n    byYear = TRUE,\n    byGender = TRUE,\n    byAge = TRUE,\n    ageBreaks = seq(0, 110, by = 10)\n  )\n)\ncohortIncidenceModuleSpecifications <- ciModuleSettingsCreator$createModuleSpecifications(\n  irDesign = irDesign$toList()\n)\n# %% [jupyter]\n# # CohortMethodModule -----------------------------------------------------------\ncmModuleSettingsCreator <- CohortMethodModule$new()\ncovariateSettings <- FeatureExtraction::createDefaultCovariateSettings(\n  addDescendantsToExclude = TRUE # Keep TRUE because you're excluding concepts\n)\noutcomeList <- append(\n  lapply(seq_len(nrow(oList)), function(i) {\n    if (useCleanWindowForPriorOutcomeLookback)\n      priorOutcomeLookback <- oList$cleanWindow[i]\n    else\n      priorOutcomeLookback <- 99999\n    CohortMethod::createOutcome(\n      outcomeId = oList$outcomeCohortId[i],\n      outcomeOfInterest = TRUE,\n      trueEffectSize = NA,\n      priorOutcomeLookback = priorOutcomeLookback\n    )\n  }),\n  lapply(negativeControlOutcomeCohortSet$cohortId, function(i) {\n    CohortMethod::createOutcome(\n      outcomeId = i,\n      outcomeOfInterest = FALSE,\n      trueEffectSize = 1\n    )\n  })\n)\ntargetComparatorOutcomesList <- list()\nfor (i in seq_len(nrow(cmTcList))) {\n  targetComparatorOutcomesList[[i]] <- CohortMethod::createTargetComparatorOutcomes(\n    targetId = cmTcList$targetCohortId[i],\n    comparatorId = cmTcList$comparatorCohortId[i],\n    outcomes = outcomeList,\n    excludedCovariateConceptIds = c(\n      cmTcList$targetConceptId[i],\n      cmTcList$comparatorConceptId[i],\n      excludedCovariateConcepts$conceptId\n    )\n  )\n}\ngetDbCohortMethodDataArgs <- CohortMethod::createGetDbCohortMethodDataArgs(\n  restrictToCommonPeriod = TRUE,\n  studyStartDate = studyStartDate,\n  studyEndDate = studyEndDate,\n  maxCohortSize = 0,\n  covariateSettings = covariateSettings\n)\ncreatePsArgs = CohortMethod::createCreatePsArgs(\n  maxCohortSizeForFitting = 250000,\n  errorOnHighCorrelation = TRUE,\n  stopOnError = FALSE, # Setting to FALSE to allow Strategus complete all CM operations; when we cannot fit a model, the equipoise diagnostic should fail\n  estimator = \"att\",\n  prior = Cyclops::createPrior(\n    priorType = \"laplace\",\n    exclude = c(0),\n    useCrossValidation = TRUE\n  ),\n  control = Cyclops::createControl(\n    noiseLevel = \"silent\",\n    cvType = \"auto\",\n    seed = 1,\n    resetCoefficients = TRUE,\n    tolerance = 2e-07,\n    cvRepetitions = 1,\n    startingVariance = 0.01\n  )\n)\nmatchOnPsArgs = CohortMethod::createMatchOnPsArgs(\n  maxRatio = psMatchMaxRatio,\n  caliper = 0.2,\n  caliperScale = \"standardized logit\",\n  allowReverseMatch = FALSE,\n  stratificationColumns = c()\n)\n# stratifyByPsArgs <- CohortMethod::createStratifyByPsArgs(\n#   numberOfStrata = 5,\n#   stratificationColumns = c(),\n#   baseSelection = \"all\"\n# )\ncomputeSharedCovariateBalanceArgs = CohortMethod::createComputeCovariateBalanceArgs(\n  maxCohortSize = 250000,\n  covariateFilter = NULL\n)\ncomputeCovariateBalanceArgs = CohortMethod::createComputeCovariateBalanceArgs(\n  maxCohortSize = 250000,\n  covariateFilter = FeatureExtraction::getDefaultTable1Specifications()\n)\nfitOutcomeModelArgs = CohortMethod::createFitOutcomeModelArgs(\n  modelType = \"cox\",\n  stratified = psMatchMaxRatio != 1,\n  useCovariates = FALSE,\n  inversePtWeighting = FALSE,\n  prior = Cyclops::createPrior(\n    priorType = \"laplace\",\n    useCrossValidation = TRUE\n  ),\n  control = Cyclops::createControl(\n    cvType = \"auto\",\n    seed = 1,\n    resetCoefficients = TRUE,\n    startingVariance = 0.01,\n    tolerance = 2e-07,\n    cvRepetitions = 1,\n    noiseLevel = \"quiet\"\n  )\n)\ncmAnalysisList <- list()\nfor (i in seq_len(nrow(timeAtRisks))) {\n  createStudyPopArgs <- CohortMethod::createCreateStudyPopulationArgs(\n    firstExposureOnly = FALSE,\n    washoutPeriod = 0,\n    removeDuplicateSubjects = \"keep first\",\n    censorAtNewRiskWindow = TRUE,\n    removeSubjectsWithPriorOutcome = TRUE,\n    priorOutcomeLookback = 99999,\n    riskWindowStart = timeAtRisks$riskWindowStart[[i]],\n    startAnchor = timeAtRisks$startAnchor[[i]],\n    riskWindowEnd = timeAtRisks$riskWindowEnd[[i]],\n    endAnchor = timeAtRisks$endAnchor[[i]],\n    minDaysAtRisk = 1,\n    maxDaysAtRisk = 99999\n  )\n  cmAnalysisList[[i]] <- CohortMethod::createCmAnalysis(\n    analysisId = i,\n    description = sprintf(\n      \"Cohort method, %s\",\n      timeAtRisks$label[i]\n    ),\n    getDbCohortMethodDataArgs = getDbCohortMethodDataArgs,\n    createStudyPopArgs = createStudyPopArgs,\n    createPsArgs = createPsArgs,\n    matchOnPsArgs = matchOnPsArgs,\n    # stratifyByPsArgs = stratifyByPsArgs,\n    computeSharedCovariateBalanceArgs = computeSharedCovariateBalanceArgs,\n    computeCovariateBalanceArgs = computeCovariateBalanceArgs,\n    fitOutcomeModelArgs = fitOutcomeModelArgs\n  )\n}\ncohortMethodModuleSpecifications <- cmModuleSettingsCreator$createModuleSpecifications(\n  cmAnalysisList = cmAnalysisList,\n  targetComparatorOutcomesList = targetComparatorOutcomesList,\n  analysesToExclude = NULL,\n  refitPsForEveryOutcome = FALSE,\n  refitPsForEveryStudyPopulation = FALSE,\n  cmDiagnosticThresholds = CohortMethod::createCmDiagnosticThresholds()\n)\n\n# %% [jupyter]\n# SelfControlledCaseSeriesmodule -----------------------------------------------\nsccsModuleSettingsCreator <- SelfControlledCaseSeriesModule$new()\nuniqueTargetIds <- sccsTList$targetCohortId\n\neoList <- list()\nfor (targetId in uniqueTargetIds) {\n  for (outcomeId in oList$outcomeCohortId) {\n    eoList[[length(eoList) + 1]] <- SelfControlledCaseSeries::createExposuresOutcome(\n      outcomeId = outcomeId,\n      exposures = list(\n        SelfControlledCaseSeries::createExposure(\n          exposureId = targetId,\n          trueEffectSize = NA\n        )\n      )\n    )\n  }\n  for (outcomeId in negativeControlOutcomeCohortSet$cohortId) {\n    eoList[[length(eoList) + 1]] <- SelfControlledCaseSeries::createExposuresOutcome(\n      outcomeId = outcomeId,\n      exposures = list(SelfControlledCaseSeries::createExposure(\n        exposureId = targetId,\n        trueEffectSize = 1\n      ))\n    )\n  }\n}\nsccsAnalysisList <- list()\nanalysisToInclude <- data.frame()\n# NOTE - NOT USING NESTING BY INDICATION\n#for (i in seq_len(nrow(sccsIList))) {\n  #indicationId <- sccsIList$indicationCohortId[i]\n  getDbSccsDataArgs <- SelfControlledCaseSeries::createGetDbSccsDataArgs(\n    maxCasesPerOutcome = 1000000,\n    useNestingCohort = FALSE,\n    #nestingCohortId = indicationId,\n    studyStartDate = studyStartDate,\n    studyEndDate = studyEndDate,\n    deleteCovariatesSmallCount = 0\n  )\n  createStudyPopulationArgs = SelfControlledCaseSeries::createCreateStudyPopulationArgs(\n    firstOutcomeOnly = TRUE,\n    naivePeriod = 365,\n    minAge = 18,\n    genderConceptIds = c(8507, 8532)\n  )\n  covarPreExp <- SelfControlledCaseSeries::createEraCovariateSettings(\n    label = \"Pre-exposure\",\n    includeEraIds = \"exposureId\",\n    start = -30,\n    startAnchor = \"era start\",\n    end = -1,\n    endAnchor = \"era start\",\n    firstOccurrenceOnly = FALSE,\n    allowRegularization = FALSE,\n    profileLikelihood = FALSE,\n    exposureOfInterest = FALSE\n  )\n  calendarTimeSettings <- SelfControlledCaseSeries::createCalendarTimeCovariateSettings(\n    calendarTimeKnots = 5,\n    allowRegularization = TRUE,\n    computeConfidenceIntervals = FALSE\n  )\n  # seasonalitySettings <- SelfControlledCaseSeries:createSeasonalityCovariateSettings(\n  #   seasonKnots = 5,\n  #   allowRegularization = TRUE,\n  #   computeConfidenceIntervals = FALSE\n  # )\n  fitSccsModelArgs <- SelfControlledCaseSeries::createFitSccsModelArgs(\n    prior = Cyclops::createPrior(\"laplace\", useCrossValidation = TRUE),\n    control = Cyclops::createControl(\n      cvType = \"auto\",\n      selectorType = \"byPid\",\n      startingVariance = 0.1,\n      seed = 1,\n      resetCoefficients = TRUE,\n      noiseLevel = \"quiet\")\n  )\n  for (j in seq_len(nrow(timeAtRisks))) {\n    covarExposureOfInt <- SelfControlledCaseSeries::createEraCovariateSettings(\n      label = \"Main\",\n      includeEraIds = \"exposureId\",\n      start = timeAtRisks$riskWindowStart[j],\n      startAnchor = gsub(\"cohort\", \"era\", timeAtRisks$startAnchor[j]),\n      end = timeAtRisks$riskWindowEnd[j],\n      endAnchor = gsub(\"cohort\", \"era\", timeAtRisks$endAnchor[j]),\n      firstOccurrenceOnly = FALSE,\n      allowRegularization = FALSE,\n      profileLikelihood = TRUE,\n      exposureOfInterest = TRUE\n    )\n    createSccsIntervalDataArgs <- SelfControlledCaseSeries::createCreateSccsIntervalDataArgs(\n      eraCovariateSettings = list(covarPreExp, covarExposureOfInt),\n      # seasonalityCovariateSettings = seasonalityCovariateSettings,\n      calendarTimeCovariateSettings = calendarTimeSettings\n    )\n    description <- \"SCCS\"\n    description <- sprintf(\"%s, male, female, age >= %s\", description, createStudyPopulationArgs$minAge)\n    description <- sprintf(\"%s, %s\", description, timeAtRisks$label[j])\n    sccsAnalysisList[[length(sccsAnalysisList) + 1]] <- SelfControlledCaseSeries::createSccsAnalysis(\n      analysisId = length(sccsAnalysisList) + 1,\n      description = description,\n      getDbSccsDataArgs = getDbSccsDataArgs,\n      createStudyPopulationArgs = createStudyPopulationArgs,\n      createIntervalDataArgs = createSccsIntervalDataArgs,\n      fitSccsModelArgs = fitSccsModelArgs\n    )\n  }\n#}\nselfControlledModuleSpecifications <- sccsModuleSettingsCreator$createModuleSpecifications(\n  sccsAnalysisList = sccsAnalysisList,\n  exposuresOutcomeList = eoList,\n  combineDataFetchAcrossOutcomes = FALSE,\n  sccsDiagnosticThresholds = SelfControlledCaseSeries::createSccsDiagnosticThresholds()\n)\n# %% [jupyter]\n# PatientLevelPredictionModule -------------------------------------------------\nplpModuleSettingsCreator <- PatientLevelPredictionModule$new()\n\nmodelSettings <- list(\n  lassoLogisticRegression = PatientLevelPrediction::setLassoLogisticRegression()\n  #randomForest = PatientLevelPrediction::setRandomForest()\n)\nmodelDesignList <- list()\nfor (cohortId in tcIds) {\n  for (j in seq_len(nrow(plpTimeAtRisks))) {\n    for (k in seq_len(nrow(oList))) {\n      if (useCleanWindowForPriorOutcomeLookback) {\n        priorOutcomeLookback <- oList$cleanWindow[k]\n      } else {\n        priorOutcomeLookback <- 99999\n      }\n      for (mSetting in modelSettings) {\n        modelDesignList[[length(modelDesignList) + 1]] <- PatientLevelPrediction::createModelDesign(\n          targetId = cohortId,\n          outcomeId = oList$outcomeCohortId[k],\n          restrictPlpDataSettings = PatientLevelPrediction::createRestrictPlpDataSettings(\n            sampleSize = 1000000,\n            studyStartDate = studyStartDate,\n            studyEndDate = studyEndDate,\n            firstExposureOnly = FALSE,\n            washoutPeriod = 0\n          ),\n          populationSettings = PatientLevelPrediction::createStudyPopulationSettings(\n            riskWindowStart = plpTimeAtRisks$riskWindowStart[j],\n            startAnchor = plpTimeAtRisks$startAnchor[j],\n            riskWindowEnd = plpTimeAtRisks$riskWindowEnd[j],\n            endAnchor = plpTimeAtRisks$endAnchor[j],\n            removeSubjectsWithPriorOutcome = TRUE,\n            priorOutcomeLookback = priorOutcomeLookback,\n            requireTimeAtRisk = FALSE,\n            binary = TRUE,\n            includeAllOutcomes = TRUE,\n            firstExposureOnly = FALSE,\n            washoutPeriod = 0,\n            minTimeAtRisk = plpTimeAtRisks$riskWindowEnd[j] - plpTimeAtRisks$riskWindowStart[j],\n            restrictTarToCohortEnd = FALSE\n          ),\n          covariateSettings = FeatureExtraction::createCovariateSettings(\n            useDemographicsGender = TRUE,\n            useDemographicsAgeGroup = TRUE,\n            useConditionGroupEraLongTerm = TRUE,\n            useDrugGroupEraLongTerm = TRUE,\n            useVisitConceptCountLongTerm = TRUE\n          ),\n          preprocessSettings = PatientLevelPrediction::createPreprocessSettings(),\n          modelSettings = mSetting\n        )\n      }\n    }\n  }\n}\nplpModuleSpecifications <- plpModuleSettingsCreator$createModuleSpecifications(\n  modelDesignList = modelDesignList\n)\n# %% [jupyter]\n# Create the analysis specifications ------------------------------------------\nanalysisSpecifications <- Strategus::createEmptyAnalysisSpecificiations() |>\n  Strategus::addSharedResources(cohortDefinitionShared) |> \n  Strategus::addSharedResources(negativeControlsShared) |>\n  Strategus::addModuleSpecifications(cohortGeneratorModuleSpecifications) |>\n  #Strategus::addModuleSpecifications(cohortDiagnosticsModuleSpecifications) |>\n  #Strategus::addModuleSpecifications(characterizationModuleSpecifications) |>\n  #Strategus::addModuleSpecifications(cohortIncidenceModuleSpecifications) |>\n  #Strategus::addModuleSpecifications(cohortMethodModuleSpecifications) |>\n  #Strategus::addModuleSpecifications(selfControlledModuleSpecifications) |>\n  Strategus::addModuleSpecifications(plpModuleSpecifications)\n\nParallelLogger::saveSettingsToJson(\n  analysisSpecifications, \n  file.path(\"tmp\", \"sampleStudySpecificationStrategus.json\")\n)\n# %% [jupyter]\n################### Execution of Study ############################\n\n# ENVIRONMENT SETTINGS NEEDED FOR RUNNING Strategus ------------\nSys.setenv(\"_JAVA_OPTIONS\"=\"-Xmx4g\") # Sets the Java maximum heap space to 4GB\nSys.setenv(\"VROOM_THREADS\"=1) # Sets the number of threads to 1 to avoid deadlocks on file system\nprint(\"done\")\n\n# %% [jupyter]\n# connect to Eunomia dataset\nconnectionDetails <- Eunomia::getEunomiaConnectionDetails()\n\n# load analysis specification files\nanalysisSpecifications <- ParallelLogger::loadSettingsFromJson(\n  fileName = \"/tmp/sampleStudySpecificationStrategus.json\"\n)\n\n# create execution settings for Strategus\nexecutionSettings <- Strategus::createCdmExecutionSettings(\n  #workDatabaseSchema = workDatabaseSchema,\n  #cdmDatabaseSchema = cdmDatabaseSchema,\n  cohortTableNames = CohortGenerator::getCohortTableNames(cohortTable = cohortTableName),\n  #workFolder = file.path(outputLocation, databaseName, \"strategusWork\"),\n  #resultsFolder = file.path(outputLocation, databaseName, \"strategusOutput\"),\n  minCellCount = minCellCount\n\n  workDatabaseSchema = \"demo_cdm\",\n  cdmDatabaseSchema = \"demo_cdm\",\n  workFolder = '/tmp/work_folder_strategus',\n  resultsFolder = '/tmp/results_folder_strategus'\n)\n\n#if (!dir.exists(file.path(outputLocation, databaseName))) {\n#  dir.create(file.path(outputLocation, databaseName), recursive = T)\n#}\n\n#ParallelLogger::saveSettingsToJson(\n#  object = executionSettings,\n#  fileName = file.path(outputLocation, databaseName, \"executionSettings.json\")\n#)\n# %% [jupyter]\nrD2E::run_strategus_flow(analysisSpecification = analysisSpecifications, executionSettings = executionSettings)\n# %% [jupyter]\nrD2E::run_strategus_flow\n# %% [python]\nimport os\nimport micropip\nawait micropip.install('ssl')\nawait micropip.install('pyjwt==2.9.0')\nawait micropip.install('https://alp-dev-sg-2.alp-dev.org/starboard-notebook-base/pyodidepyqe-0.0.2-py3-none-any.whl', keep_going=True)\nos.environ['PYQE_URL'] = 'analytics-svc/'\nos.environ['TOKEN'] = 'eyJhbGciOiJFUzM4NCIsInR5cCI6ImF0K2p3dCIsImtpZCI6IlZRSUMzcnNzVWZNbHRKaUxGUUV6UG5ycXhGdGlERFllZE1tbFF2Q3BNdEUifQ.eyJqdGkiOiJOUDlxbF85WjBnUmNReWhSdWdNZjAiLCJzdWIiOiJqaGliZ2lhcmgzODgiLCJpYXQiOjE3NTE2MDQ1NzEsImV4cCI6MTc1MTYwODE3MSwic2NvcGUiOiIiLCJjbGllbnRfaWQiOiIxZDZ3dXlkYW55YWl5cGJrY2h4enUiLCJpc3MiOiJodHRwczovL2FscC1kZXYtc2ctMi5hbHAtZGV2Lm9yZy9vaWRjIiwiYXVkIjoiaHR0cHM6Ly9hbHAtZGVmYXVsdCJ9.vcDWOGalndPrOQgjALOQTFrd7HmufqwUtBm8TLUImg3NwuDmJGeBGt23CfudqamARld9yVsCYf7jnvAgdza5x5_XyP1VOx26TRJv10segEE_MiNoeHUgZ9adx5Zz86wY'\nos.environ['PYQE_TLS_CLIENT_CA_CERT_PATH'] = ''",
    "isShared":false,
    "datasetId":"67f4015c-04f0-4a92-939b-20c361c2e50a"
}